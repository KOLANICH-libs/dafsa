---
title: 'DAFDA: A Python package for Deterministic Acyclic Finite State Automata'
tags:
  - Python
  - finite state automata
  - deterministic acyclic finite state automaton
  - directed acyclic word graph
  - sequence analysis
  - morphology
authors:
  - name: Tiago Tresoldi
    orcid: 0000-0002-2863-1467
    affiliation: 1 # (Multiple affiliations must be quoted)
affiliations:
 - name: post-doc, Max Planck Institute for the Science of Human History
   index: 1
date: 12 December 2019
bibliography: paper.bib
---

# Summary

``DAFSA`` is a Python library for computing [Deterministic Acyclic Finite State Automata](https://en.wikipedia.org/wiki/Deterministic_acyclic_finite_state_automaton) (also known as "directed acyclic word graphs", or DAWG). DAFSA are data structures derived from [tries](https://en.wikipedia.org/wiki/Trie) that allow to represent a set of sequences (typically character strings or *n*-grams) in the form of a directed acyclic graph with a single source vertex (the `start` symbol of all sequences) and at least one sink edge (`final` symbols, each pointed to by one or more sequences). In the current implementation, a trait of each node expresses whether it can be used a sink.

The primary difference between DAFSA and tries is that the latter eliminates suffix and infix redundancy, as in the example of Figure 1 (from the linked Wikipedia article) storing the set of strings `"tap"`, `"taps"`, `"top"`, and `"tops"`. Even though DAFSAs cannot be used to store precise frequency information, given that multiple paths might reach the same terminal node, they still allow to estimate the sampling frequency; being acyclic, they can also reject any sequence not included in the training. Fuzzy extensions will allow to estimate the sampling probability of unobserved sequences.

![Trie vs. DAFSA](https://raw.githubusercontent.com/tresoldi/dafsa/master/figures/trie-vs-dafsa.png)

This data structure is a special case of a finite state recognizer that acts as a deterministic finite state automaton, as it recognizes all and only the sequences it was built upon. Frequently used in computer science for the space-efficient storage of sets of sequences without common compression techniques, such as dictionary or entropy types, or without probabilistic data structures, such as Bloom filters, the automata generated by this library are intended for linguistic exploration, and extend published models by allowing to approximate probability of random observation by carrying information on the weight of each graph edge.

# Installation and usage

The library can be installed as any standard Python library with
`pip`, and used as demonstrated in the following snippet:

In any standard Python environment, `dafsa` can be installed with:

```bash
$ pip install dafsa
```

Detailed instructions on how to use the library can be found in the
[official documentation](https://dafsa.readthedocs.io/en/latest/quickstart.html).
For most purposes, it is enough to pass a list of sequences to
the `DAFSA` object:

```python
>>> from dafsa import DAFSA
>>> print(DAFSA(["dib", "tip", "tips", "top"]))
DAFSA with 8 nodes and 9 edges (4 inserted sequences)
  +-- #0: 0(#1/4:<d>/1|#4/4:<t>/3) [('t', 4), ('d', 1)]
  +-- #1: n(#2/1:<i>/1) [('i', 2)]
  +-- #2: n(#3/1:<b>/1) [('b', 3)]
  +-- #3: F() []
  +-- #4: n(#5/3:<i>/2|#8/3:<o>/1) [('i', 5), ('o', 8)]
  +-- #5: n(#6/2:<p>/2) [('p', 6)]
  +-- #6: F(#3/2:<s>/1) [('s', 3)]
  +-- #8: n(#3/1:<p>/1) [('p', 3)]
```

It can be exported, checked for presence/absence (along with weight).
Single path joining can be performed.

Full documentation is available [at ReadTheDocs.io](https://dafsa.readthedocs.io).

# Alternatives

The main alternative to this library is the ``dawg`` one, available at
https://github.com/pytries/DAWG. ``dawg`` wraps the ``dwagdic`` C++
library, and is intended to production usage of DAFSAs as a
space-efficient data structure. It does not support the computation of
edge weights, nor it is intended for exporting the internal structure as
a graph.

Other alternatives are the ``adfa`` and ``minim`` packages, written in
C/C++, written by Jan Daciuk. Note on archive.

# Citations

Holding all citations here, @Black:2008, [@Blumer:1985],
@Ciura:2001, @Daciuk:2000, @Lucchesi:1993,
@Havon:2011.

# Acknowledgements

The author has received funding from the European Research Council (ERC)
under the European Unionâ€™s Horizon 2020 research and innovation
programme (grant agreement
No. [ERC Grant #715618](https://cordis.europa.eu/project/rcn/206320/factsheet/en),
[Computer-Assisted Language Comparison](https://digling.org/calc/).

# References
