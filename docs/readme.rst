DAFSA Library
=============

DAFSA is a library for computing `Deterministic Acyclic Finite State
Automata <https://en.wikipedia.org/wiki/Deterministic_acyclic_finite_state_automaton>`__
(also known as “directed acyclic word graphs”, or DAWG). DAFSA are data
structures derived from `tries <https://en.wikipedia.org/wiki/Trie>`__
that allow to represent a set of sequences (typically character strings
or *n*-grams) in the form of a directed acyclic graph with a single
source vertex (the ``start`` symbol of all sequences) and at least one
sink edge (``end`` symbols, each pointed to by one or more sequences).
In the current implementation, a trait of each node expresses whether it
can be used a sink.

The primary difference between DAFSA and tries is that the latter
eliminates suffix and infix redundancy, as in the example of Figure 1
(from the linked Wikipedia article) storing the set of strings
``"tap"``, ``"taps"``, ``"top"``, and ``"tops"``. Even though DAFSAs
cannot be used to store precise frequency information, given that
multiple paths can reach the same terminal node, they still allow to
estimate the sampling frequency; being acyclic, they can also reject any
sequence not included in the training. Fuzzy extensions will allow to
estimate the sampling probability of unobserved sequences.

.. figure:: https://raw.githubusercontent.com/tresoldi/dafsa/master/figures/trie-vs-dafsa.png
   :alt: Trie vs. DAFSA

   Trie vs. DAFSA

This data structure is a special case of a finite state recognizer that
acts as a deterministic finite state automaton, as it recognizes all and
only the sequences it was built upon. Frequently used in computer
science for the space-efficient storage of sets of sequences without
common compression techniques, such as dictionary or entropy types, or
without probabilistic data structures, such as Bloom filters, the
automata generated by this library are intended for linguistic
exploration, and extend published models by allowing to approximate
probability of random observation by carrying information on the weight
of each graph edge.

Installation
------------

In any standard Python environment, ``dafsa`` can be installed with:

::

   pip install dafsa

Alternatives
------------

The main alternative to this library is the ``dawg`` one, available at
https://github.com/pytries/DAWG. ``dawg`` wraps the ``dwagdic`` C++
library, and is intended to production usage of DAFSAs as a
space-efficient data structure. It does not support the computation of
edge weights, nor it is intended for exporting the internal structure as
a graph.

Other alternatives are the ``adfa`` and ``minim`` packages, written in
C/C++, written by Jan Daciuk. The personal webpage hosting them has been
offline for years, with a version at the `Wayback
Machine <https://web.archive.org/web/20160531133017/http://galaxy.eti.pg.gda.pl/katedry/kiw/pracownicy/Jan.Daciuk/personal/minim.html>`__
available. Note that the archived version does *not* include the
packages.

How to cite
-----------

If you use ``dafsa``, please cite it as:

   Tresoldi, Tiago (2019). DAFSA, a a library for computing
   Deterministic Acyclic Finite State Automata. Version 0.4. Jena.
   Available at: https://github.com/tresoldi/dafsa

In BibTeX:

.. code:: bibtex

   @misc{Tresoldi2019dafsa,
     author = {Tresoldi, Tiago},
     title = {DAFSA, a a library for computing Deterministic Acyclic Finite State Automata. Version 0.4},
     howpublished = {\url{https://github.com/tresoldi/dafsa}},
     address = {Jena},
     year = {2019},
   }

References
----------

Black, Paul E. and Pieterse, Vreda (eds.). 1998. “Directed acyclic word
graph”, *Dictionary of Algorithms and Data Structures*. Gaithersburg:
National Institute of Standards and Technology.

Blumer, Anselm C.; Blumer, Janet A.; Haussler, David; Ehrenfeucht,
Andrzej; Chen, M.T.; Seiferas, Joel I. 1985. “The smallest automaton
recognizing the subwords of a text”, *Theoretical Computer Science*, 40:
31–55.
`doi:10.1016/0304-3975(85)90157-4 <https://doi.org/10.1016%2F0304-3975%2885%2990157-4>`__.

Ciura, Marcin G. and Deorowicz, Sebastian. 2002. “How to sequeeze a
lexicon”, *Software-Practice and Experience* 31(11):1077-1090.

Daciuk, Jan; Mihov, Stoyan; Watson, Bruce and Watson, Richard. 2000.
“Incremental construction of minimal acyclic finite state automata.”
*Computational Linguistics* 26(1):3-16.

Havon, Steve. 2011. “Compressing dictionaries with a DAWG”. *Steve
Hanov’s Blog*. `url <http://stevehanov.ca/blog/?id=115>`__

Lucchesi, Cláudio L. and Kowaltowski, Tomasz. “Applications of finite
automata representing large vocabularies”. *Software-Practice and
Experience*. 1993: 15–30. `CiteSeerX
10.1.1.56.5272 <https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.56.5272>`__.

Author
------

Tiago Tresoldi (tresoldi@shh.mpg.de)

The author was supported during development by the
`ERC Grant #715618 <https://cordis.europa.eu/project/rcn/206320/factsheet/en>`__
for the project `CALC <http://calc.digling.org>`__
(Computer-Assisted Language Comparison: Reconciling Computational and Classical
Approaches in Historical Linguistics).
